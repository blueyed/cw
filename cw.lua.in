#!/bin/sh
A=--[[ exec @LUA@ "$0" "$@"  # -*- mode: lua; -*- ]]A

prog = { name = "@PACKAGE@" }

-- Remove current directory from package.path
package.path = package.path:gsub (";%./%?%.lua", ""):gsub ("^%./%?%.lua;", "")

-- Fudge package.cpath when running in-tree
local IN_TREE_LUA_PATH = "@in_tree_lua_path@"
if IN_TREE_LUA_PATH ~= "" then
  package.cpath = IN_TREE_LUA_PATH .. ";" .. package.cpath
end

require "std"
local posix = require "posix"
local rex = require "rex_posix"
local cw = require "consolewrap"

local scrname = arg[1]
local base_scrname = posix.basename(scrname or arg[0])

if #arg < 1 or arg[1] == "--help" then
  io.stderr:write ("Usage: not for direct use; use via definition files (see cw(1)):\n" ..
                   "  --version             display version information and exit\n" ..
                   "  --help                display this help and exit\n")
  os.exit ()
elseif arg[1] == "--version" then
  die ("cw (color wrapper) v@VERSION@")
end

-- Filter a directory out of a PATH-like colon-separated path list.
local function remove_dir_from_path(path, dir)
  local canon_dir = cw.canonicalize_file_name (dir)
  if not canon_dir then return path end
  return table.concat (list.filter (function (s) return cw.canonicalize_file_name (s) ~= canon_dir end,
                                    path:split (":")), ":")
end

posix.setenv ("PATH", remove_dir_from_path (os.getenv("PATH"), "@pkgdatadir@"))

local color_name
local color_name_real = {"black","blue","green","cyan","red","purple","brown",
                         "grey+","grey","blue+","green+","cyan+","red+","purple+","yellow","white",
                         "default"}
local color_name_real_invert = {"white","blue+","green+","cyan+","red+","purple+",
                                "yellow","grey","grey+","blue","green","cyan","red","purple","brown","black",
                                "default"}
local colors = #color_name_real
local color_code = {"\x1b[00;30m","\x1b[00;34m","\x1b[00;32m",
                    "\x1b[00;36m","\x1b[00;31m","\x1b[00;35m","\x1b[00;33m","\x1b[00;37m",
                    "\x1b[01;30m","\x1b[01;34m","\x1b[01;32m","\x1b[01;36m","\x1b[01;31m",
                    "\x1b[01;35m","\x1b[01;33m","\x1b[01;37m","\x1b[00m"}

color_name = os.getenv ("CW_INVERT") and color_name_real_invert or color_name_real

local colormap = {}

-- Convert a color type to a physical color, defaulting to the base color.
local function type_to_color (color)
  return colormap[color] or colormap["base"]
end

local default_colormap = "base=cyan:bright=cyan+:highlight=green+:lowlight=green:neutral=white:warning=yellow:error=red+:punctuation=blue+"

-- Set user color map.
local function setcolors (str)
  local tmp = str
  for ass in list.elems (str:split (":")) do
    local t = ass:split ("=")
    local log, phys = t[1], t[2]
    if log and #log > 0 then
      if phys and #phys > 0 then
        colormap[log] = phys
      else
        die ("physical color missing or invalid.")
      end
    else
      die ("logical color missing or invalid.")
    end
  end
end

setcolors ("base=default") -- Ensure there is a "base" type
setcolors (os.getenv ("CW_COLORS") or default_colormap)

local matches = {}

function match (col, regex)
  table.insert (matches, {col = type_to_color (col), regex = regex})
end

-- Create a coloring array for a string.
local rex_flags = rex.flags ()
local function make_colors (s)
  local cols = list.rep ({type_to_color ("base")}, #s) -- Fill color array with base color.
  for m in list.elems (matches) do
    local r = rex.new (m.regex)
    if r then
      local j = 1
      while j < #s do
        local from, to = r:find (s, j, j > 1 and rex_flags.NOTBOL or 0)
        if not from then break end
        cols = cols:slice (1, from - 1) .. list.rep ({m.col}, to - from + 1) .. cols:slice (to + 1)
        if to == from then
          to = to + 1 -- Make sure we advance at least one character.
        end
        j = to
      end
    end
  end
 return cols
end

-- Color a string given a coloring array.
local color_name_to_n = table.invert (color_name)
local function apply_colors (s, color)
  local tbuf = ""
  local col -- nil guarantees immediate change of color
  for i = 1, #s do
    if col ~= color[i] then
      col = color[i]
      tbuf = tbuf .. color_code[color_name_to_n[col]]
    end
    tbuf = tbuf .. s[i]
  end
  if col ~= "default" then
    tbuf = tbuf .. color_code[color_name_to_n["default"]]
  end
  return tbuf
end

-- Color a string based on the definition file.
local function convert_string (s)
  return apply_colors (s, make_colors (s))
end

local ok, msg = pcall (dofile, scrname)
if ok == false then
  die ("error in definition file: " .. msg)
end

local nocolor = os.getenv("NOCOLOR")
local nocolor_stdout = not posix.isatty (posix.STDOUT_FILENO)
local nocolor_stderr = not posix.isatty (posix.STDERR_FILENO)
if not nocolor and not (nocolor_stdout and nocolor_stderr) then
  local ret = cw.wrap_child (convert_string)
  if ret then -- Non-nil, so in parent process
    os.exit (ret)
  end
end

-- Child process
local cmd = base_scrname
if command then
  local cmdline = tostring (command)
  if not cmdline then
    die ("invalid command given.")
  end
  cmd = "/bin/sh"
  arg = {[0] = base_scrname, "-c", cmdline} -- FIXME: needs argv[0]-setting support in luaposix to work
else
  table.remove (arg, 1)
end
posix.execp (cmd, unpack (arg))
