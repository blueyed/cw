#!/bin/sh
A=--[[ exec @LUA@ "$0" "$@"  # -*- mode: lua; -*- ]]A
--
-- cw (color wrapper)
--
-- Copyright (c) 2013 Reuben Thomas <rrt@sc3d.org>
--
-- This file is part of cw.
--
-- cw is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3, or (at your option)
-- any later version.
--
-- cw is distributed in the hope that it will be useful, but
-- WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-- General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with cw; see the file COPYING.  If not, see
-- <http://www.gnu.org/licenses/>. */


prog = { name = "@PACKAGE@" }

-- Remove current directory from package.path
package.path = package.path:gsub (";%./%?%.lua", ""):gsub ("^%./%?%.lua;", "")

require "std"
local posix = require "posix"
local colors = require "ansicolors"

local scrname = arg[1]
local base_scrname = posix.basename(scrname or arg[0])

if #arg < 1 or arg[1] == "--help" then
  io.stderr:write ("Usage: not for direct use; use via definition files (see cw(1)):\n" ..
                   "  --version             display version information and exit\n" ..
                   "  --help                display this help and exit\n")
  os.exit ()
elseif arg[1] == "--version" then
  io.stderr:write ("cw (color wrapper) v@VERSION@\n")
  os.exit ()
end

-- Filter a directory out of a PATH-like colon-separated path list.
local function remove_dir_from_path(path, dir)
  local canon_dir = posix.realpath (dir)
  return table.concat (list.filter (function (s) return posix.realpath (s) ~= canon_dir end,
                                    path:split (":")), ":")
end

posix.setenv ("PATH", remove_dir_from_path (os.getenv("PATH"), "@pkglibexecdir@"))

local colormap = {}

-- Convert a lexical class to a color, defaulting to the color of the base class.
local function class_to_color (class)
  return colormap[class] or colormap["base"]
end

-- Set user color map.
local function setcolors (str)
  for ass in list.elems (str:split (":")) do
    local class, col = unpack (ass:split ("="))
    if not class or #class == 0 then
      die ("class missing.")
    end
    if not col or #col == 0 then
      die ("color missing.")
    end
    colormap[class] = colors.noReset ("%{reset " .. col .. "}")
  end
end

setcolors ("base=reset") -- Ensure there is a "base" class
setcolors (os.getenv ("CW_COLORS") or (os.getenv ("CW_INVERT") and
  "base=yellow:bright=bright yellow:highlight=bright magenta:lowlight=magenta:neutral=bright black:warning=bright blue:error=bright red:punctuation=bright green" or
  "base=cyan:bright=bright cyan:highlight=bright green:lowlight=green:neutral=bright white:warning=bright yellow:error=bright red:punctuation=bright blue"))
local nocolor = os.getenv("NOCOLOR") or os.getenv("TERM") == "dumb" -- read NOCOLOR before definition script

local matches = list.new ()

function match (class, regex)
  table.insert (matches, {col = class_to_color (class), regex = regex})
end

-- Create a coloring array for a string.
local function make_colors (s)
  local cols = list.rep ({class_to_color ("base")}, #s) -- Fill color array with base color.
  for m in matches:elems () do
    for c in list.elems (s:finds (m.regex)) do
      local from, to = unpack (c)
      cols = cols:sub (1, from - 1) .. list.rep ({m.col}, to - from + 1) .. cols:sub (to + 1)
    end
  end
 return cols
end

-- Color a string given a coloring array.
local function apply_colors (s, color)
  local tbuf = ""
  local col -- nil guarantees immediate change of color
  for i = 1, #s do
    if col ~= color[i] then
      col = color[i]
      tbuf = tbuf .. col
    end
    tbuf = tbuf .. s[i]
  end
  if col ~= "reset" then
    tbuf = tbuf .. colors.noReset ("%{reset}")
  end
  return tbuf
end

-- Run definition script
table.remove (arg, 1)
table.merge (arg, table.invert (arg)) -- add arguments as keys
local ok, msg = pcall (dofile, scrname)
if ok == false then
  die ("error in definition file: " .. msg)
end

-- Take chunks of input, color it line by line, and write the result.
if not nocolor and posix.isatty (posix.STDOUT_FILENO) == 1 then
  local master, slave = posix.openpty ()
  local buf = ""
  local exit = false
  local pid_c

  local function chld_handler ()
    posix.fcntl (master, posix.F_SETFL, posix.O_NONBLOCK)
    exit = true
  end
  local function int_handler ()
    posix.write (posix.STDOUT_FILENO, "\x1b[00m")
    if pid_c ~= 0 then
      posix.killpg (pid_c, posix.SIGINT)
    end
    error ("interrupted")
  end

  if not master then
    die ("openpty error.")
  end
  local old_chld_handler = posix.signal (posix.SIGCHLD, chld_handler, posix.SA_NOCLDSTOP)
  local old_int_handler = posix.signal (posix.SIGINT, int_handler)

  pid_c = posix.fork ()
  if pid_c == nil then -- FIXME: Report error?
    die ("fork() error.")
  elseif pid_c == 0 then
    -- child process to execute the program.
    if not posix.dup2 (slave, posix.STDOUT_FILENO) then -- FIXME: Report error?
      die ("dup2() failed.")
    end
    posix.setpid ('s')
  else
    -- parent process to filter the program's output; kills children if interrupted.
    repeat
      local chunk = posix.read (master, posix.BUFSIZ)
      if (not chunk or #chunk == 0) and exit == true then
        break
      end
      buf = buf .. chunk
      local lines = buf:split ("\r\n")
      buf = lines[#lines]
      for i = 1, #lines - 1 do
        local s = apply_colors (lines[i], make_colors (lines[i]))
        if s then
          posix.write (posix.STDOUT_FILENO, s .. "\n")
        end
      end
    until false
    -- FIXME: print anything left in buf
    local _, _, ret = posix.wait (pid_c)
    os.exit (ret)
  end
  posix.signal (posix.SIGCHLD, old_chld_handler)
  posix.signal (posix.SIGINT, old_int_handler)
end

-- Child process
local cmd = base_scrname
if command then
  if not type (command) == "string" then
    die ("invalid command given.")
  end
  cmd = "/bin/sh"
  arg = {[0] = base_scrname, "-c", command}
else
  arg[0] = nil
end
posix.execp (cmd, arg)
-- FIXME: turn off coloring for error
die ("could not run command: " .. cmd)
